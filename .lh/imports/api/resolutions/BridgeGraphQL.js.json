{
    "sourceFile": "imports/api/resolutions/BridgeGraphQL.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1678462321825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1678462321825,
            "name": "Commit-0",
            "content": "import { getNullableType, isEnumType, isInputObjectType, isListType, isNonNullType, isObjectType, isScalarType, } from 'graphql';\nimport invariant from 'invariant';\nimport lowerCase from 'lodash/lowerCase';\nimport memoize from 'lodash/memoize';\nimport upperFirst from 'lodash/upperFirst';\nimport { Bridge, joinName } from 'uniforms';\nfunction fieldInvariant(name, condition) {\n    invariant(condition, 'Field not found in schema: \"%s\"', name);\n}\nexport default class GraphQLBridge extends Bridge {\n    constructor(schema, validator, extras = {}) {\n        super();\n        this.schema = schema;\n        this.validator = validator;\n        this.extras = extras;\n        // Memoize for performance and referential equality.\n        this.getField = memoize(this.getField.bind(this));\n        this.getInitialValue = memoize(this.getInitialValue.bind(this));\n        this.getProps = memoize(this.getProps.bind(this));\n        this.getSubfields = memoize(this.getSubfields.bind(this));\n        this.getType = memoize(this.getType.bind(this));\n    }\n    // TODO: Get rid of this `any`.\n    getError(name, error) {\n        const details = error === null || error === void 0 ? void 0 : error.details;\n        if (!Array.isArray(details)) {\n            return null;\n        }\n        return details.find(error => error.name === name) || null;\n    }\n    // TODO: Get rid of this `any`.\n    getErrorMessage(name, error) {\n        const scopedError = this.getError(name, error);\n        return (scopedError === null || scopedError === void 0 ? void 0 : scopedError.message) || '';\n    }\n    // TODO: Get rid of this `any`.\n    getErrorMessages(error) {\n        if (!error) {\n            return [];\n        }\n        const { details } = error;\n        return Array.isArray(details)\n            ? details.map(error => error.message)\n            : [error.message || error];\n    }\n    getField(name) {\n        return joinName(null, name).reduce((field, namePart) => {\n            const fieldType = getNullableType(field.type);\n            if (namePart === '$' || namePart === '' + parseInt(namePart, 10)) {\n                fieldInvariant(name, isListType(fieldType));\n                return Object.assign(Object.assign({}, field), { type: fieldType.ofType });\n            }\n            if (isInputObjectType(fieldType) || isObjectType(fieldType)) {\n                const fields = fieldType.getFields();\n                fieldInvariant(name, namePart in fields);\n                return fields[namePart];\n            }\n            fieldInvariant(name, false);\n        }, { name: '', type: this.schema });\n    }\n    getInitialValue(name) {\n        var _a;\n        const type = this.getType(name);\n        if (type === Array) {\n            return [];\n        }\n        if (type === Object) {\n            const value = {};\n            this.getSubfields(name).forEach(key => {\n                const initialValue = this.getInitialValue(joinName(name, key));\n                if (initialValue !== undefined) {\n                    value[key] = initialValue;\n                }\n            });\n            return value;\n        }\n        const { defaultValue } = this.getField(name);\n        // @ts-expect-error The `extras` should be typed more precisely.\n        return defaultValue !== null && defaultValue !== void 0 ? defaultValue : (_a = this.extras[name]) === null || _a === void 0 ? void 0 : _a.initialValue;\n    }\n    getProps(nameNormal) {\n        var _a;\n        const nameGeneric = nameNormal.replace(/\\.\\d+/g, '.$');\n        const field = this.getField(nameGeneric);\n        const props = Object.assign(Object.assign({ required: isNonNullType(field.type) }, this.extras[nameGeneric]), this.extras[nameNormal]);\n        const fieldType = getNullableType(field.type);\n        if (isScalarType(fieldType) && fieldType.name === 'Float') {\n            props.decimal = true;\n        }\n        (_a = props.label) !== null && _a !== void 0 ? _a : (props.label = upperFirst(lowerCase(field.name)));\n        const options = props.options;\n        if (options) {\n            if (Array.isArray(options)) {\n                props.allowedValues = options.map(option => option.value);\n                props.transform = (value) => options.find(option => option.value === value).label;\n            }\n            else {\n                props.allowedValues = Object.keys(options);\n                props.transform = (value) => options[value];\n            }\n        }\n        else if (isEnumType(fieldType)) {\n            const values = fieldType.getValues();\n            props.allowedValues = values.map(option => option.value);\n            props.transform = (value) => values.find(searchValue => searchValue.value === value).name;\n        }\n        return props;\n    }\n    getSubfields(name = '') {\n        const type = getNullableType(this.getField(name).type);\n        return isInputObjectType(type) || isObjectType(type)\n            ? Object.keys(type.getFields())\n            : [];\n    }\n    getType(name) {\n        const type = getNullableType(this.getField(name).type);\n        if (isInputObjectType(type) || isObjectType(type)) {\n            return Object;\n        }\n        if (isListType(type)) {\n            return Array;\n        }\n        if (isScalarType(type)) {\n            if (type.name === 'Boolean') {\n                return Boolean;\n            }\n            if (type.name === 'Float') {\n                return Number;\n            }\n            if (type.name === 'ID') {\n                return String;\n            }\n            if (type.name === 'Int') {\n                return Number;\n            }\n            if (type.name === 'String') {\n                return String;\n            }\n        }\n        return type;\n    }\n    getValidator( /* options */) {\n        return this.validator;\n    }\n}\n"
        }
    ]
}